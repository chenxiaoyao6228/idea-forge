generator client {
  provider      = "prisma-client-js"
  binaryTargets = ["native", "linux-musl-openssl-3.0.x"]
}

generator zod {
  provider                         = "zod-prisma-types"
  output                           = "../../contracts/src/schema"
  useMultipleFiles                 = true // default is false
  writeBarrelFiles                 = true // default is true
  createInputTypes                 = false // default is true
  createModelTypes                 = true // default is true
  addInputTypeValidation           = false // default is true
  addIncludeType                   = false // default is true
  addSelectType                    = false // default is true
  validateWhereUniqueInput         = false // default is false
  createOptionalDefaultValuesTypes = true // default is false
  createRelationValuesTypes        = false // default is false
  createPartialTypes               = false // default is false
  useDefaultValidators             = true // default is true
  coerceDate                       = true // default is true
  writeNullishInModelTypes         = false // default is false
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model UnifiedPermission {
  id           String          @id @default(cuid())
  userId       String? // Make nullable for guest scenarios  
  resourceType ResourceType // DOCUMENT, SUBSPACE, WORKSPACE
  resourceId   String // DOCUMENT_ID, SUBSPACE_ID, WORKSPACE_ID, etc
  permission   PermissionLevel // NONE, READ, COMMENT, EDIT, MANAGE, OWNER
  sourceType   SourceType // DIRECT, GROUP, SUBSPACE_ADMIN, SUBSPACE_MEMBER, WORKSPACE_ADMIN, WORKSPACE_MEMBER, GUEST
  sourceId     String?
  priority     Int // 1-7, 1 is the highest priority
  createdAt    DateTime        @default(now())
  updatedAt    DateTime        @updatedAt
  createdById  String

  // Optional for guest permissions    
  guestId String?

  source   UnifiedPermission?  @relation("PermissionInheritance", fields: [sourceId], references: [id])
  children UnifiedPermission[] @relation("PermissionInheritance")

  unifiedUser      User?              @relation("UserPermissions", fields: [userId], references: [id])
  unifiedCreatedBy User               @relation("CreatedPermissions", fields: [createdById], references: [id])
  guest            GuestCollaborator? @relation(fields: [guestId], references: [id])

  // Updated unique constraint to handle both scenarios  
  @@unique([userId, guestId, resourceType, resourceId, sourceType])
  @@index([userId, resourceType])
  @@index([guestId, resourceType])
  @@index([resourceType, resourceId])
  @@index([priority])
}

enum ResourceType {
  WORKSPACE
  SUBSPACE
  DOCUMENT
}

enum SourceType {
  DIRECT // directly assigned permission (priority: 1)    
  GROUP // group permission (priority: 2)      
  SUBSPACE_ADMIN // subspace admin (priority: 3)    
  SUBSPACE_MEMBER // subspace member (priority: 4)    
  WORKSPACE_ADMIN // workspace admin (priority: 5)    
  WORKSPACE_MEMBER // workspace member (priority: 6)    
  GUEST // guest permission (priority: 7)  
}

enum PermissionLevel {
  NONE
  READ
  COMMENT
  EDIT
  MANAGE
  OWNER
}

model User {
  id          String  @id @default(uuid())
  email       String  @unique
  displayName String? // Display name (used as primary identifier)
  imageUrl    String? // Profile image URL

  // Account status
  emailVerified DateTime? // Email verification timestamp
  status        UserStatus @default(PENDING) // Account status

  // Timestamps
  createdAt DateTime @default(now()) @db.Timestamp() // Account creation time
  updatedAt DateTime @updatedAt // Last update time

  // Security
  hashedRefreshToken String? // Refresh token for authentication
  password           Password? // Hashed password
  connections        Connection[] // OAuth connections

  // Document relationships
  authoredDocs     Doc[]      @relation("DocAuthor") // Documents created by user
  createdDocs      Doc[]      @relation("DocCreator") // Documents created by user
  lastModifiedDocs Doc[]      @relation("DocLastModifier") // Documents last modified by user
  sharedDocs       DocShare[] @relation("SharedToUser") // Documents shared with user
  docShare         DocShare[] // Documents shared by user

  // permissions
  unifiedPermissions        UnifiedPermission[] @relation("UserPermissions")
  createdUnifiedPermissions UnifiedPermission[] @relation("CreatedPermissions")

  // Version history
  docRevisions DocRevision[] // Document revision history

  // File storage
  file         File[] // Files uploaded by user
  aiTokenUsage AITokenUsage? // AI token usage tracking

  // Activity logs
  userLoginHistory UserLoginHistory[] // User login history records

  // Workspace memberships
  workspaceMembers WorkspaceMember[] // Workspace memberships
  subspaceMembers  SubspaceMember[] // Subspace memberships

  // Group memberships
  memberGroups MemberGroupUser[] // Group memberships

  // Guest invitations
  guestInvitations GuestCollaborator[] @relation("InvitedBy") // Guest invitations sent

  // Star relationships
  stars Star[] // User's starred items
}

enum UserStatus {
  PENDING // Registration pending verification (email/phone not verified)
  ACTIVE // Normal active status
  SUSPENDED // Temporarily suspended (violation of rules, etc.)
  REVOKED // Permanently banned (serious violation)
  ARCHIVED // Account archived (long-term inactive)
}

model Workspace {
  id              String   @id @default(cuid())
  allowPublicDocs Boolean  @default(false)
  name            String
  description     String?
  avatar          String?
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  settings Json?

  // relations
  subspaces    Subspace[]
  members      WorkspaceMember[]
  guests       GuestCollaborator[]
  memberGroups MemberGroup[]
  docs         Doc[]
}

enum DocVisibility {
  PUBLIC // visible to everyone, (eg: product user guide, etc.)
  SHARED // visible to specific members, need further permission control check
  PRIVATE // visible to author
  WORKSPACE // visible to workspace, need further permission control check
}

model Doc {
  id            String  @id @default(cuid())
  type          DocType @default(NOTE)
  title         String
  content       String  @default("{}") // doc json snapshot
  contentBinary Bytes? // yjs collaborative document

  // state mark
  archivedAt  DateTime?
  publishedAt DateTime?
  deletedAt   DateTime?

  // position
  parentId String?
  index    String? // Fractional index for my-docs ordering

  // timestamps
  updatedAt DateTime @updatedAt
  createdAt DateTime @default(now())

  // appearance
  icon         String?
  coverImage   CoverImage?
  coverImageId String?

  // visibility
  visibility DocVisibility @default(WORKSPACE)

  // relations
  author   User   @relation("DocAuthor", fields: [authorId], references: [id])
  authorId String

  createdBy   User   @relation("DocCreator", fields: [createdById], references: [id])
  createdById String

  lastModifiedBy   User   @relation("DocLastModifier", fields: [lastModifiedById], references: [id])
  lastModifiedById String

  workspace   Workspace @relation(fields: [workspaceId], references: [id])
  workspaceId String

  subspace   Subspace? @relation(fields: [subspaceId], references: [id])
  subspaceId String?

  parent   Doc?  @relation("DocToDoc", fields: [parentId], references: [id], onDelete: NoAction, onUpdate: NoAction)
  children Doc[] @relation("DocToDoc")

  // sharing and permissions
  docShare DocShare[]

  // publicShare        PublicShare?

  // versions
  revisions DocRevision[]

  // star relationships
  stars Star[] // Stars for this document
}

model WorkspaceMember {
  id        String        @id @default(cuid())
  role      WorkspaceRole @default(MEMBER)
  createdAt DateTime      @default(now())
  updatedAt DateTime      @updatedAt

  preferences Json? // User preferences
  index       String? // Fractional index for ordering

  workspace   Workspace @relation(fields: [workspaceId], references: [id])
  workspaceId String
  user        User      @relation(fields: [userId], references: [id])
  userId      String

  @@unique([workspaceId, userId])
  @@index([userId, index])
}

model Subspace {
  id          String       @id @default(cuid())
  name        String
  description String?
  avatar      String?
  type        SubspaceType @default(PUBLIC)
  createdAt   DateTime     @default(now())
  updatedAt   DateTime     @updatedAt
  settings    Json?

  isArchived Boolean @default(false)

  navigationTree Json?
  index          String?

  // relations
  workspace   Workspace        @relation(fields: [workspaceId], references: [id])
  workspaceId String
  docs        Doc[]
  members     SubspaceMember[]

  // star relationships
  stars Star[] // Stars for this subspace
}

model SubspaceMember {
  id        String       @id @default(cuid())
  role      SubspaceRole @default(MEMBER)
  createdAt DateTime     @default(now())
  updatedAt DateTime     @default(now())

  subspace   Subspace @relation(fields: [subspaceId], references: [id])
  subspaceId String

  user   User   @relation(fields: [userId], references: [id])
  userId String

  @@unique([subspaceId, userId])
}

enum SubspaceType {
  WORKSPACE_WIDE //  All workspace members are automatically members of this space (cannot leave). 
  PUBLIC // Any workspace member can join and leave freely. 
  INVITE_ONLY // Visible to all members but requires invitation to join.
  PRIVATE //  Only visible to invited members, completely hidden from others.
  PERSONAL // Only visible to the creator, completely hidden from others.
}

// Group of users in workspace
model MemberGroup {
  id          String    @id @default(cuid())
  name        String
  description String?
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  validUntil  DateTime?

  workspace   Workspace         @relation(fields: [workspaceId], references: [id])
  workspaceId String
  members     MemberGroupUser[]
}

model MemberGroupUser {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())

  group   MemberGroup @relation(fields: [groupId], references: [id])
  groupId String
  user    User        @relation(fields: [userId], references: [id])
  userId  String

  @@unique([groupId, userId])
}

// User belongs to other workspace, but come to current workspace as a guest
// can be upgraded to workspace member
model GuestCollaborator {
  id        String      @id @default(cuid())
  email     String
  name      String?
  status    GuestStatus @default(PENDING)
  expireAt  DateTime
  createdAt DateTime    @default(now())
  updatedAt DateTime    @updatedAt

  invitedBy          User                @relation("InvitedBy", fields: [invitedById], references: [id])
  invitedById        String
  workspace          Workspace           @relation(fields: [workspaceId], references: [id])
  workspaceId        String
  unifiedPermissions UnifiedPermission[]

  @@unique([email, workspaceId])
}

enum GuestStatus {
  PENDING
  ACTIVE
  EXPIRED
  REVOKED
}

model DocShare {
  id       String @id @default(cuid())
  doc      Doc    @relation(fields: [docId], references: [id], onDelete: Cascade)
  docId    String
  author   User   @relation(fields: [authorId], references: [id], onDelete: Cascade)
  authorId String
  sharedTo User   @relation("SharedToUser", fields: [userId], references: [id], onDelete: Cascade)
  userId   String

  permission PermissionLevel @default(READ)

  // Key field: Support folder tree sharing
  includeChildDocuments Boolean @default(false) // Whether to include child documents

  // Share status control  
  published Boolean   @default(false) // Whether publicly published
  revokedAt DateTime? // Revocation time

  // Access control  
  expiresAt DateTime? // Expiration time
  urlId     String? // Custom URL identifier

  // Statistics  
  viewCount      Int       @default(0) // Number of views
  lastAccessedAt DateTime? // Last access time

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([docId, userId])
  @@index([userId, createdAt])
  @@index([docId, includeChildDocuments])
}

model Password {
  hash String

  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  userId String @unique
}

model Connection {
  id           String @id @default(cuid())
  providerName String // Provider name: github, google etc.
  providerId   String // Provider's user ID

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId String

  @@unique([providerName, providerId])
}

model CoverImage {
  id       String  @id @default(cuid())
  url      String
  scrollY  Float
  doc      Doc     @relation(fields: [docId], references: [id])
  docId    String  @unique
  isPreset Boolean @default(false)
}

model DocRevision {
  id            String   @id @default(cuid())
  title         String
  content       String
  contentBinary Bytes?
  createdAt     DateTime @default(now())

  doc      Doc    @relation(fields: [docId], references: [id], onDelete: Cascade)
  docId    String
  author   User   @relation(fields: [authorId], references: [id])
  authorId String

  @@index([docId, createdAt])
}

model File {
  id          String   @id @default(cuid())
  key         String   @unique
  url         String   @default("")
  status      String   @default("pending") // pending/active/deleted
  size        Int      @default(0)
  userId      String
  user        User     @relation(fields: [userId], references: [id])
  contentType String
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
}

model AITokenUsage {
  id            String   @id @default(cuid())
  user          User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId        String   @unique
  tokensUsed    Int      @default(0)
  lastResetDate DateTime @default(now())
  monthlyLimit  Int      @default(10000)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([userId, lastResetDate])
}

model UserLoginHistory {
  id        String   @id @default(cuid())
  userId    String
  ip        String?
  location  String?
  loginTime DateTime @default(now())
  user      User     @relation(fields: [userId], references: [id])

  @@index([userId])
}

model Star {
  id        String   @id @default(cuid())
  index     String?  @db.VarChar(256) // For sorting
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations 
  user       User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId     String
  doc        Doc?      @relation(fields: [docId], references: [id], onDelete: Cascade)
  docId      String?
  subspace   Subspace? @relation(fields: [subspaceId], references: [id], onDelete: Cascade)
  subspaceId String?

  // Ensure each user can only star a resource once
  @@unique([userId, docId])
  @@unique([userId, subspaceId])
  // Ensure docId and subspaceId cannot both be null
  @@unique([docId, subspaceId])
}

enum WorkspaceRole {
  OWNER // Can delete the workspace/transfer ownership/has all ADMIN permissions
  ADMIN // Can manage workspace settings, add/remove members, add/remove member groups, manage all documents in the workspace, etc
  MEMBER // Can create documents/ join subspaces/ create member groups(if allowed in workspace settings) / Cannot see private content unless explicitly shared
}

enum SubspaceRole {
  ADMIN // Can manage subspace settings, add/remove members, manage  all documents in the subspace, etc
  MEMBER
}

enum DocType {
  NOTE
  WHITEBOARD
  MIND
}
