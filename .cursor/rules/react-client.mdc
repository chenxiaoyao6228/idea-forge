---
description: React Client Code Style Guide for Idea Forge
globs: ["apps/client/**/*.tsx"]
alwaysApply: false
---

# React Client Code Style Guide for Idea Forge

This document serves as the definitive guide for code style, patterns, and conventions used in the Idea Forge React client. This guide should be used as context for all future code generation and development work.

## Table of Contents

- [Project Overview](mdc:#project-overview)
- [General TypeScript Guidelines](mdc:#general-typescript-guidelines)
- [File and Directory Structure](mdc:#file-and-directory-structure)
- [Component Architecture](mdc:#component-architecture)
- [State Management](mdc:#state-management)
- [Hooks and Custom Hooks](mdc:#hooks-and-custom-hooks)
- [Styling and UI](mdc:#styling-and-ui)
- [Internationalization (i18n)](mdc:#internationalization-i18n)
- [API Integration](mdc:#api-integration)
- [Routing](mdc:#routing)
- [Testing Patterns](mdc:#testing-patterns)
- [Performance Optimization](mdc:#performance-optimization)
- [Modal Management](mdc:#modal-management)

## Project Overview

This is a modern Notion-like note taking React application built with:

- **React 18.x** - UI library with concurrent features
- **TypeScript 5.x** - Strict type checking enabled
- **Vite** - Fast build tool and dev server
- **React Router** - Client-side routing
- **React Use** - Primitive react hook sets
- **@ahooksjs/use-request** - Async request management
- **Zustand** - Lightweight state management
- **TipTap** - Rich text editor with collaboration
- **Yjs** - Real-time collaboration
- **Shadcn UI** - Component library built on Radix
- **Tailwind CSS** - Utility-first CSS framework
- **Socket.io** - Websocket lib
- **Class Variance Authority (CVA)** - Component variant management
- **Lucide React** - Icon library
- **Vitest** - Testing framework
- **react-confirm** - Modal and confirmation dialog management

## General TypeScript Guidelines

### Basic Principles

- Use English for all code and documentation
- Always declare types for variables and functions (avoid `any`)
- Use strict TypeScript configuration
- Use functional and declarative programming patterns
- Avoid classes; prefer functions and hooks
- Use descriptive variable names with auxiliary verbs (e.g., `isLoading`, `hasError`)
- Favor iteration and modularization over duplication (DRY principles)

### Naming Conventions

```typescript
// PascalCase for components, interfaces, types
export interface UserProps {}
export type UserStatus = "active" | "inactive";
export function UserCard() {}

// camelCase for variables, functions, methods
const userName = "john";

// kebab-case for files and directories
'user-data.ts";

// UPPERCASE for constants
const MAX_RETRY_ATTEMPTS = 3;
const API_ENDPOINTS = {
  USERS: "/api/users",
  DOCUMENTS: "/api/documents",
} as const;

// Use verbs for boolean variables
const isLoading = true;
const hasError = false;
const canDelete = user.role === "admin";
// use verb for action
const checkStar = ()=> {}
```

### TypeScript Conventions

```typescript
// Use interfaces for object shapes
interface User {
  id: string;
  email: string;
  firstName: string;
  lastName: string;
  role: UserRole;
}

// Use type aliases for unions and complex types
type UserStatus = "active" | "inactive" | "pending";
type ApiResponse<T> = { data: T; message: string };

// Use generic types for reusable components
interface ListProps<T> {
  items: T[];
  renderItem: (item: T) => React.ReactNode;
  keyExtractor: (item: T) => string;
}

// Use proper typing for event handlers
const handleSubmit = (event: React.FormEvent<HTMLFormElement>) => {
  event.preventDefault();
  // handle form submission
};
```

## File and Directory Structure

### Project Structure

```
apps/client/src/
├── main.tsx                    # Application entry point
├── App.tsx                     # Root component
├── index.css                   # Global styles
├── vite-env.d.ts              # Vite type definitions
├── components/                 # Reusable components
│   ├── ui/                     # Base UI components (Shadcn)
│   │   ├── button.tsx
│   │   ├── input.tsx
│   │   └── dialog.tsx
│   ├── editor/                 # TipTap editor components
│   └── collaboration/          # Collaboration components
├── pages/                      # Page components
│   ├── auth/
│   ├── dashboard/
│   ├── documents/
│   └── settings/
├── hooks/                      # Custom hooks
│   ├── use-auth.ts
│   ├── use-documents.ts
│   └── use-collaboration.ts
├── stores/                     # Zustand stores
│   ├── auth.ts
│   ├── document.ts
│   └── ui.ts
├── lib/                        # Utility libraries
│   ├── api.ts
│   ├── utils.ts
│   ├── constants.ts
│   └── validations.ts
├── types/                      # TypeScript type definitions
│   ├── user.ts
│   ├── document.ts
│   └── api.ts
├── router/                     # Routing configuration
│   ├── routes.tsx
│   └── guards.tsx
├── constants/                  # Application constants
├── assets/                     # Static assets
└── hocs/                       # Higher-order components
```

### Component Structure

Each component follows this structure:

```
components/feature-name/
├── feature-name.tsx            # Main component
├── feature-name.types.ts       # Component types(if too many types exported from the component)
└── index.ts                    # Barrel export
```

### File Naming Conventions

- Use kebab-case: `user-card.tsx`
- Use descriptive names: `document-editor.tsx`, `collaboration-cursor.tsx`
- Include type in filename: `.types.ts`, `.store.ts`, `.hook.ts`
- Use singular names for components: `user-card.tsx` not `user-cards.tsx`

## Component Architecture

### Separation of UI and Logic

**MANDATORY: Components MUST separate UI rendering from business logic. Business logic should be encapsulated in stores, custom hooks, or utility functions.**

#### ✅ Correct Pattern - Logic in Store

```typescript
// Store handles all business logic
const useStarStore = create<StarStoreState>()((set, get) => ({
  // ... other state and actions

  // Business logic method
  getNavigationNodeForStar: (star) => {
    // Complex logic for finding navigation nodes
    // across different data sources
    if (star.subspaceId) {
      const subspace = useSubSpaceStore.getState().entities[star.subspaceId];
      if (!subspace) return null;
      return {
        id: subspace.id,
        title: subspace.name,
        type: NavigationNodeType.Subspace,
        url: `/subspace/${subspace.id}`,
        children: subspace.navigationTree || [],
        parent: null,
      };
    }

    // More complex logic...
    return null;
  },
}));

// Component only handles UI rendering
export function StarLink({ star }: StarLinkProps) {
  const getNavigationNodeForStar = useStarStore(
    (state) => state.getNavigationNodeForStar
  );

  // Simple UI logic only
  const navigationNode = useMemo(() => {
    return getNavigationNodeForStar(star);
  }, [star, getNavigationNodeForStar]);

  if (!navigationNode) return null;

  return (
    <div className="star-link">
      <SidebarLink
        to={navigationNode.url || `/${navigationNode.id}`}
        icon={<StarIcon className="h-4 w-4 text-yellow-500" />}
        label={navigationNode.title}
        // ... other UI props
      />
    </div>
  );
}
```

#### ❌ Incorrect Pattern - Logic in Component

```typescript
// ❌ DON'T: Complex business logic in component
export function StarLink({ star }: StarLinkProps) {
  const [isLoading, setIsLoading] = useState(false);
  const document = useDocumentStore((state) => state.entities[star.docId || ""]);
  const subspace = useSubSpaceStore((state) => state.entities[star.subspaceId || ""]);
  const sharedDocuments = useSharedWithMeStore((state) => state.documents);

  // ❌ Complex business logic in component
  const findNavigationNode = useCallback((docId: string, nodes: NavigationNode[]): NavigationNode | null => {
    for (const node of nodes) {
      if (node.id === docId) {
        return node;
      }
      if (node.children) {
        const found = findNavigationNode(docId, node.children);
        if (found) return found;
      }
    }
    return null;
  }, []);

  // ❌ More complex logic...
  const navigationNode = useMemo(() => {
    if (!star.docId) return null;

    // Check subspace navigation tree
    if (subspace?.navigationTree) {
      const found = findNavigationNode(star.docId, subspace.navigationTree);
      if (found) return found;
    }

    // Check personal subspace...
    // Check shared documents...
    // etc...
  }, [star.docId, subspace, findNavigationNode]);

  // ❌ Data fetching logic in component
  useEffect(() => {
    if (star.docId && !document && !isLoading) {
      setIsLoading(true);
      fetchDocumentDetail(star.docId, { silent: true })
        .catch((error) => {
          console.warn(`Failed to fetch document ${star.docId}:`, error);
        })
        .finally(() => {
          setIsLoading(false);
        });
    }
  }, [star.docId, document, isLoading, fetchDocumentDetail]);

  // Component is now bloated with business logic
  return (
    // ... UI rendering
  );
}
```

#### Separation Principles

1. **Store Methods**: Complex business logic should be in store methods
2. **Custom Hooks**: Reusable logic should be in custom hooks
3. **Utility Functions**: Pure functions should be in utility modules
4. **Component Focus**: Components should only handle UI rendering and simple state
5. **Single Responsibility**: Each layer should have a single, clear responsibility

### Functional Component Pattern

1. **Use functional components with hooks**
2. **Use TypeScript interfaces for props**
3. **Use descriptive prop names**
4. **Handle loading and error states**
5. **Use proper event handling**
6. **Implement proper accessibility** d
7. **Use composition over inheritance**
8. **Keep components focused and single-purpose**
9. **Use proper error boundaries**
10. **Implement proper cleanup in useEffect**
11. **MANDATORY: Separate UI from business logic** - Components should only handle UI rendering, not complex business logic
12. **Encapsulate business logic in stores or custom hooks** - Keep components clean and focused on presentation
13. **Avoid data fetching in components** - Use stores or custom hooks for data management
14. **Minimize component complexity** - If a component has too much logic, extract it to a store or hook

### Modal Management

**MANDATORY: All modal dialogs, confirmations, and popups MUST use `react-confirm` library. Do NOT use native browser `confirm()`, `alert()`, or custom modal implementations.**

**MANDATORY: All modal dialogs, confirmations, and popups MUST use name start with`show`, eg: `showSubspaceModal`**

for simple confirmation, use the predefined custom confirm modal

```ts
// import
import { showConfirmModal } from "@/components/ui/confirm-modal";
// usage
showConfirmModal({
  type: "alert",
  confirmVariant: "destructive",
  title: t("Permanent Delete"),
  description: t(
    "Are you sure you want to permanently delete this document? This action cannot be undone."
  ),
  confirmText: t("Delete"),
  cancelText: t("Cancel"),
  onConfirm: async () => {
    try {
      await documentApi.permanentDelete(id);
      await loadTrashDocuments();
      toast.success(t("Document deleted permanently"));
      return true;
    } catch (error: any) {
      if (error?.code === ErrorCodeEnum.DocumentNotFound) {
        // refresh trash documents
        toast.error(t("Document not found in trash"));
        await loadTrashDocuments();
        return false;
      }
      toast.error(t("Failed to delete document"));
      return false;
    }
  },
});
```

## State Management

### Hook-Based Store Architecture

**MANDATORY: Use the new hook-based architecture for all state management. This provides better developer experience, maintainability, and WebSocket compatibility.**

#### Architecture Principles

1. **Minimal Store**: Only state and basic mutations
2. **Root-level CRUD Hooks**: Individual hooks for each operation
3. **Custom useRequest**: Handle loading states automatically
4. **Clean Computed Values**: Use React's `useMemo`
5. **WebSocket Compatible**: Direct store mutations work seamlessly
6. **Separation of Concerns**: UI logic separate from business logic

#### Store Structure Pattern

**MANDATORY: Stores should only contain state and a unified `changeState` method.
**Store Rules:\*\*

1. **Only State**: Store should only contain state properties
2. **Unified changeState**: Single method to update any state property
3. **No CRUD Methods**: No individual add/update/remove methods in store
4. **Hook-based CRUD**: All CRUD operations implemented as hooks

```typescript
// ✅ Minimal store - only state and unified changeState method
const useStarStore = create<{
  stars: StarEntity[];
  starsMap: Record<string, StarEntity>;
  currentStar: StarEntity | null;
  changeState: (
    updates: Partial<{
      stars: StarEntity[];
      starsMap: Record<string, StarEntity>;
      currentStar: StarEntity | null;
    }>
  ) => void;
}>((set) => ({
  stars: [],
  starsMap: {},
  currentStar: null,

  // Unified state update method
  changeState: (updates) => set((state) => ({ ...state, ...updates })),
}));

// ❌ Avoid: Individual CRUD methods in store
const useStarStore = create<{
  stars: StarEntity[];
  setStars: (stars: StarEntity[]) => void;
  addStar: (star: StarEntity) => void;
  updateStar: (id: string, changes: Partial<StarEntity>) => void;
  removeStar: (id: string) => void;
}>((set) => ({
  // ... individual methods
}));
```

#### CRUD Operations with Direct Store Updates

**MANDATORY: Use direct `changeState` calls for all CRUD operations instead of store methods.**

**For CRUD operations, use direct store updates:**

- **Fetch**: `changeState({ items: newItems })`
- **Create**: `changeState({ items: [...items, newItem] })`
- **Update**: `changeState({ items: items.map(item => item.id === id ? updatedItem : item) })`
- **Delete**: `changeState({ items: items.filter(item => item.id !== id) })`

```typescript

**Cleaner Approach:**
- Update store state directly with `changeState` instead of syncing
- No need for separate management hooks with `useEffect` sync
- Simpler, more direct, and easier to understand

// ✅ Split into focused hooks for better performance
// Each hook only subscribes to what it actually needs

// Benefits of splitting hooks:
// 1. Components only re-render when their specific dependencies change
// 2. Better performance through selective subscriptions
// 3. Clearer intent - each hook has a single responsibility
// 4. Easier to test and maintain
// 5. More granular control over re-renders

// Only subscribe to stars array
export const useStars = () => {
  const stars = useStarStore((state) => state.stars);
  return { stars };
};

// Only subscribe to currentStar
export const useCurrentStar = () => {
  const currentStar = useStarStore((state) => state.currentStar);
  return { currentStar };
};

// Computed values that depend on stars
export const useOrderedStars = () => {
  const stars = useStarStore((state) => state.stars);

  const orderedStars = useMemo(
    () => stars.sort((a, b) => (a.index || "").localeCompare(b.index || "")),
    [stars]
  );

  return { orderedStars };
};

// Grouped stars by subspace
export const useStarsBySubspace = () => {
  const stars = useStarStore((state) => state.stars);

  const starsBySubspace = useMemo(() => groupBy(stars, "subspaceId"), [stars]);

  return { starsBySubspace };
};

// Star checking utility
export const useIsStarred = () => {
  const stars = useStarStore((state) => state.stars);

  const isStarred = RefCallback(
    (docId?: string, subspaceId?: string) => {
      return stars.some(
        (star) =>
          (docId && star.docId === docId) ||
          (subspaceId && star.subspaceId === subspaceId)
      );
    },

  );

  return { isStarred };
};



// ✅ Create operation - Direct store updates
export const useCreateStar = () => {
  const { stars, changeState } = useStarStore();

  return useRequest(
    async (params: CreateStarDto) => {
      try {
        const response = await starApi.create(params);
        // Update store directly
        changeState({ stars: [...stars, response.data] });
        toast.success("Star created");
        return response;
      } catch (error) {
        console.error("Failed to create star:", error);
        toast.error("Failed to create star", {
          description: error.message,
        });
        throw error;
      }
    },
    {
      manual: true,
    }
  );
};

// ✅ Update operation - Direct store updates

```

### Store Best Practices

1. **Use Zustand for client state management**
2. **Use devtools middleware for debugging**
3. **Separate state and actions clearly**
4. **Handle loading and error states**
5. **Use proper TypeScript typing**
6. **Implement proper error handling**
7. **Use localStorage for persistence when needed**
8. **Keep stores focused and single-purpose**
9. **MANDATORY: Use hook-based architecture for all new stores**
10. **MANDATORY: Separate UI logic from business logic**
11. **MANDATORY: Use individual CRUD hooks for each operation**
12. **MANDATORY: Use useRequest for automatic loading state management**

## Hooks and Custom Hooks

### Hook Library Strategy

**MANDATORY: Use react-use for basic functionality, @ahooksjs/use-request for async operations, and useRefCallback for stable function references.**

```typescript
// ✅ useRefCallback implementation
import { useRef, useCallback } from "react";

export function useRefCallback<T extends (...args: any[]) => any>(fn: T): T {
  const fnRef = useRef(fn);
  fnRef.current = fn;
  return useCallback(
    (...args: Parameters<T>) => fnRef.current(...args),
    []
  ) as T;
}
```

### useRequest Pattern

**MANDATORY: Use @ahooksjs/use-request for all async operations. It provides automatic loading states, error handling.**

**PREFERRED: Use try-catch blocks within async functions instead of onSuccess/onError callbacks for better control flow and error handling.**

**Benefits of try-catch pattern:**

- Better error handling control
- Cleaner code flow
- Easier to add complex success logic
- Better TypeScript support
- Consistent with modern async/await patterns

```typescript
import useRequest from "@ahooksjs/use-request";

// ✅ Preferred: Try-catch style with manual execution
const { data, loading, error, run } = useRequest(
  async () => {
    try {
      const response = await api.getData();
      toast.success("Data loaded successfully");
      return response.data;
    } catch (error) {
      console.error("Failed to load data:", error);
      toast.error("Failed to load data", {
        description: error.message,
      });
      throw error;
    }
  },
  {
    manual: true, // Manual execution for better control
  }
);

// ❌ Avoid: onSuccess/onError callbacks (legacy pattern)
const { data, loading, error, run } = useRequest(
  async () => {
    const response = await api.getData();
    return response.data;
  },
  {
    onSuccess: (data) => {
      toast.success("Data loaded successfully");
    },
    onError: (error) => {
      toast.error("Failed to load data", {
        description: error.message,
      });
    },
  }
);

// ✅ Manual trigger
const { data, loading, error, run } = useRequest(
  async (params: CreateParams) => {
    const response = await api.create(params);
    return response.data;
  },
  {
    manual: true, // Don't auto-trigger
    onSuccess: (data) => {
      toast.success("Created successfully");
    },
  }
);

// ✅ Conditional execution
const { data, loading, error } = useRequest(
  async () => {
    const response = await api.getData();
    return response.data;
  },
  {
    ready: !!userId, // Only run when userId exists
    refreshDeps: [userId], // Re-run when userId changes
  }
);

// ✅ Pagination
const { data, loading, error, run } = useRequest(
  async (page: number) => {
    const response = await api.getData({ page, limit: 25 });
    return response.data;
  },
  {
    manual: true,
    onSuccess: (result) => {
      if (result.page === 1) {
        setAllData(result.data);
      } else {
        setAllData((prev) => [...prev, ...result.data]);
      }
    },
  }
);
```

### Custom Hook Patterns

#### State Management Hooks

```typescript
// ✅ Toggle hook with stable reference
export function useToggle<T>(initialValue: T, alternateValue: T) {
  const [state, setState] = useState(initialValue);

  const toggle = useRefCallback(() => {
    setState((current) =>
      current === initialValue ? alternateValue : initialValue
    );
  });

  return [state, toggle] as const;
}

// ✅ Counter hook
export function useCounter(initialValue: number = 0) {
  const [count, setCount] = useState(initialValue);

  const increment = useRefCallback(() => setCount((prev) => prev + 1));
  const decrement = useRefCallback(() => setCount((prev) => prev - 1));
  const reset = useRefCallback(() => setCount(initialValue));

  return { count, increment, decrement, reset };
}
```

#### Async Operation Hooks

```typescript
// ✅ Async operation hook
export function useAsyncOperation<T, P extends any[]>(
  asyncFn: (...args: P) => Promise<T>
) {
  const [data, setData] = useState<T | null>(null);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<Error | null>(null);

  const execute = useRefCallback(async (...args: P) => {
    setLoading(true);
    setError(null);
    try {
      const result = await asyncFn(...args);
      setData(result);
      return result;
    } catch (err) {
      const error = err instanceof Error ? err : new Error(String(err));
      setError(error);
      throw error;
    } finally {
      setLoading(false);
    }
  });

  return { data, loading, error, execute };
}
```

#### Event Handler Hooks

```typescript
// ✅ Debounced callback
export function useDebouncedCallback<T extends (...args: any[]) => any>(
  callback: T,
  delay: number
): T {
  const timeoutRef = useRef<NodeJS.Timeout>();

  const debouncedCallback = useRefCallback((...args: Parameters<T>) => {
    if (timeoutRef.current) clearTimeout(timeoutRef.current);
    timeoutRef.current = setTimeout(() => callback(...args), delay);
  });

  useEffect(
    () => () => {
      if (timeoutRef.current) clearTimeout(timeoutRef.current);
    },
    []
  );

  return debouncedCallback as T;
}
```

### Hook Best Practices

#### DO ✅

1. **Use useRefCallback for all function references**
2. **Use react-use for basic functionality**
3. **Use @ahooksjs/use-request for async operations**
4. **Keep hooks focused and single-purpose**
5. **Handle cleanup in useEffect**
6. **Return stable references**

#### DON'T ❌

1. **Don't use useCallback for function references**
2. **Don't use TanStack Query - use @ahooksjs/use-request instead**
3. **Don't forget cleanup in useEffect**
4. **Don't return unstable references**
5. **Don't use hooks inside conditions or loops**

## Styling and UI

1. **Use Shadcn UI components as base**
2. **Use Radix UI for accessibility**
3. **Use Tailwind CSS for styling**
4. **Use CVA for component variants**
5. **Implement responsive design**
6. **Support dark mode**
7. **Use proper spacing and typography**
8. **Implement proper accessibility**
9. **Use consistent design tokens**
10. **Follow mobile-first approach**

## Internationalization (i18n)

### i18n Design Principles

**MANDATORY: Always consider internationalization when designing and implementing pages. Take character length variations into account to avoid text truncation and other unexpected behavior across different languages.**

### Character Length Considerations

Different languages have significantly different character lengths for the same concept:

```typescript
// Example: "Delete" button text lengths
const deleteTexts = {
  en: "Delete", // 6 characters
  de: "Löschen", // 7 characters
  fr: "Supprimer", // 10 characters
  es: "Eliminar", // 8 characters
  zh: "删除", // 2 characters
  ja: "削除", // 2 characters
  ru: "Удалить", // 7 characters
  ar: "حذف", // 2 characters
};
```

### UI Design Guidelines for i18n

#### 1. Flexible Layout Design

```typescript
// ✅ Good: Flexible button sizing
<Button
  className="min-w-[80px] px-4 py-2" // Minimum width with padding
  variant="destructive"
>
  {t("Delete")}
</Button>

// ❌ Bad: Fixed width that may truncate
<Button
  className="w-20" // Fixed width may be too small for some languages
  variant="destructive"
>
  {t("Delete")}
</Button>
```

#### 2. Responsive Text Containers

```typescript
// ✅ Good: Flexible text containers
<div className="flex-1 min-w-0"> {/* Allows shrinking */}
  <h3 className="truncate" title={document.title}>
    {document.title}
  </h3>
  <p className="text-sm text-muted-foreground line-clamp-2">
    {document.description}
  </p>
</div>

// ❌ Bad: Fixed width containers
<div className="w-48"> {/* May be too narrow for longer text */}
  <h3>{document.title}</h3>
</div>
```

#### 3. Table and List Design

```typescript
// ✅ Good: Responsive table with flexible columns
<div className="overflow-x-auto">
  <table className="w-full min-w-[600px]">
    {" "}
    {/* Minimum width for content */}
    <thead>
      <tr>
        <th className="text-left min-w-[200px]">{t("Document Name")}</th>
        <th className="text-left min-w-[120px]">{t("Last Modified")}</th>
        <th className="text-left min-w-[100px]">{t("Status")}</th>
        <th className="text-right min-w-[80px]">{t("Actions")}</th>
      </tr>
    </thead>
    <tbody>
      {documents.map((doc) => (
        <tr key={doc.id}>
          <td className="truncate max-w-[200px]" title={doc.title}>
            {doc.title}
          </td>
          <td>{formatDate(doc.updatedAt)}</td>
          <td>
            <Badge variant={getStatusVariant(doc.status)}>
              {t(doc.status)}
            </Badge>
          </td>
          <td className="text-right">
            <DropdownMenu>{/* Actions */}</DropdownMenu>
          </td>
        </tr>
      ))}
    </tbody>
  </table>
</div>
```

#### 4. Form Design Considerations

```typescript
// ✅ Good: Flexible form layout
<div className="space-y-4">
  <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
    <div className="space-y-2">
      <Label htmlFor="firstName" className="text-sm font-medium">
        {t("First Name")}
      </Label>
      <Input
        id="firstName"
        className="w-full" // Full width within container
        placeholder={t("Enter your first name")}
      />
    </div>
    <div className="space-y-2">
      <Label htmlFor="lastName" className="text-sm font-medium">
        {t("Last Name")}
      </Label>
      <Input
        id="lastName"
        className="w-full"
        placeholder={t("Enter your last name")}
      />
    </div>
  </div>

  <div className="space-y-2">
    <Label htmlFor="description" className="text-sm font-medium">
      {t("Description")}
    </Label>
    <Textarea
      id="description"
      className="w-full min-h-[100px] resize-y" // Flexible height
      placeholder={t("Enter a detailed description of your project")}
    />
  </div>
</div>
```

### Text Length Testing Strategy

#### 1. Test with Long Text

```typescript
// ✅ Good: Test component with various text lengths
const testTexts = {
  short: "Hi",
  medium: "This is a medium length text",
  long: "This is a very long text that might cause layout issues in some languages and should be handled properly with truncation or wrapping",
  veryLong:
    "This is an extremely long text that contains many words and might cause significant layout issues in various languages and should definitely be tested to ensure proper handling of text overflow and responsive design",
};

// Test component with different text lengths
<DocumentCard title={testTexts.long} description={testTexts.veryLong} />;
```

#### 2. Use CSS for Text Handling

```css
/* ✅ Good: CSS classes for text handling */
.text-truncate {
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}

.text-wrap {
  word-wrap: break-word;
  overflow-wrap: break-word;
  hyphens: auto;
}

.line-clamp-2 {
  display: -webkit-box;
  -webkit-line-clamp: 2;
  -webkit-box-orient: vertical;
  overflow: hidden;
}
```

### i18n Implementation Patterns

#### 1. Translation Hook Usage

```typescript
// ✅ Good: Proper translation usage
import { useTranslation } from "react-i18next";

export function DocumentActions({ document }: DocumentActionsProps) {
  const { t } = useTranslation();

  return (
    <div className="flex gap-2">
      <Button
        size="sm"
        variant="outline"
        className="min-w-[60px]" // Minimum width for button
      >
        {t("Edit")}
      </Button>
      <Button
        size="sm"
        variant="destructive"
        className="min-w-[70px]" // Slightly larger for "Delete"
      >
        {t("Delete")}
      </Button>
    </div>
  );
}
```

#### 2. Dynamic Content Handling

```typescript
// ✅ Good: Handle dynamic content with proper spacing
export function UserProfile({ user }: UserProfileProps) {
  const { t } = useTranslation();

  return (
    <div className="space-y-4">
      <div className="flex items-center gap-3">
        <Avatar className="h-12 w-12">
          <AvatarImage src={user.avatar} />
          <AvatarFallback>{user.name.charAt(0)}</AvatarFallback>
        </Avatar>
        <div className="flex-1 min-w-0">
          {" "}
          {/* Flexible container */}
          <h2 className="font-semibold truncate" title={user.name}>
            {user.name}
          </h2>
          <p className="text-sm text-muted-foreground truncate">{t("Last active: {{date}}", { date: formatDate(user.lastActive) })}</p>
        </div>
      </div>
    </div>
  );
}
```

### Common i18n Pitfalls to Avoid

#### 1. Fixed Width Elements

```typescript
// ❌ Bad: Fixed widths that don't accommodate longer text
<div className="w-32"> {/* Too narrow for some languages */}
  <Button>{t("Create New Document")}</Button>
</div>

// ✅ Good: Flexible widths with minimum constraints
<div className="min-w-[120px]">
  <Button className="w-full">{t("Create New Document")}</Button>
</div>
```

#### 2. Hardcoded Text Lengths

```typescript
// ❌ Bad: Assuming text length
const maxLength = 50; // May be too short for some languages

// ✅ Good: Language-aware length limits
const getMaxLength = (language: string) => {
  const limits = {
    en: 50,
    de: 60, // German tends to be longer
    zh: 25, // Chinese characters are more compact
    ja: 30,
  };
  return limits[language] || 50;
};
```

#### 3. Ignoring Text Direction

```typescript
// ✅ Good: Support for RTL languages
<div className="text-left rtl:text-right"> {/* RTL support */}
  <p>{t("Welcome to our application")}</p>
</div>

// ✅ Good: Flexible icon positioning
<div className="flex items-center gap-2 rtl:flex-row-reverse">
  <Icon className="h-4 w-4" />
  <span>{t("Settings")}</span>
</div>
```

### i18n Best Practices

#### DO ✅

1. **Always use flexible layouts** - Avoid fixed widths for text containers
2. **Test with long text** - Use placeholder text of varying lengths
3. **Use CSS truncation** - Implement proper text overflow handling
4. **Consider text direction** - Support RTL languages when needed
5. **Use semantic HTML** - Proper heading hierarchy and landmarks
6. **Implement responsive design** - Ensure layouts work on all screen sizes
7. **Use translation keys consistently** - Follow naming conventions
8. **Handle dynamic content** - Account for variable-length translated content

#### DON'T ❌

1. **Don't use fixed widths** - Text length varies significantly across languages
2. **Don't assume text length** - Always test with longer translations
3. **Don't ignore text overflow** - Implement proper truncation or wrapping
4. **Don't hardcode text** - Always use translation functions
5. **Don't forget RTL support** - Consider right-to-left languages
6. **Don't use absolute positioning** - Use flexible layouts instead
7. **Don't ignore mobile layouts** - Ensure responsive design works with longer text

## API Integration

### API Client Pattern

```typescript
// use contracts from packages/contract, if have no one, please define them in that folder
import type { ListDocumentResponse, ListDocumentDto } from "@idea/contracts";
// API functions
export const documentApi = {
  list: async (data: ListDocumentDto) => {
    return request.post<ListDocumentDto, ListDocumentResponse>(
      `/api/documents/list`,
      data
    );
  },
};
```

## Routing

### Route Configuration Pattern

```typescript
import React from "react";
import { createBrowserRouter, Navigate } from "react-router-dom";
import { Layout } from "@/components/layout/layout";
import { AuthGuard } from "@/router/guards";
import { LoginPage } from "@/pages/auth/login-page";
import { DashboardPage } from "@/pages/dashboard/dashboard-page";
import { DocumentPage } from "@/pages/documents/document-page";
import { SettingsPage } from "@/pages/settings/settings-page";

export const router = createBrowserRouter([
  {
    path: "/",
    element: <Layout />,
    children: [
      {
        index: true,
        element: <Navigate to="/dashboard" replace />,
      },
      {
        path: "login",
        element: <LoginPage />,
      },
      {
        path: "dashboard",
        element: (
          <AuthGuard>
            <DashboardPage />
          </AuthGuard>
        ),
      },
      {
        path: "documents/:id",
        element: (
          <AuthGuard>
            <DocumentPage />
          </AuthGuard>
        ),
      },
      {
        path: "settings",
        element: (
          <AuthGuard>
            <SettingsPage />
          </AuthGuard>
        ),
      },
    ],
  },
]);
```

### Route Guard Pattern

```typescript
import React from "react";
import { Navigate, useLocation } from "react-router-dom";
import { useAuthStore } from "@/stores/auth-store";

interface AuthGuardProps {
  children: React.ReactNode;
}

export function AuthGuard({ children }: AuthGuardProps) {
  const { user, isLoading } = useAuthStore();
  const location = useLocation();

  if (isLoading) {
    return <div>Loading...</div>;
  }

  if (!user) {
    return <Navigate to="/login" state={{ from: location }} replace />;
  }

  return <>{children}</>;
}
```

### Hook Test Pattern

```typescript
import { renderHook, waitFor } from "@testing-library/react";
import { QueryClient, QueryClientProvider } from "@tanstack/react-query";
import { useDocuments } from "./use-documents";

const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      retry: false,
    },
  },
});

const TestWrapper = ({ children }: { children: React.ReactNode }) => (
  <QueryClientProvider client={queryClient}>{children}</QueryClientProvider>
);

describe("useDocuments", () => {
  it("fetches documents successfully", async () => {
    const mockDocuments = [
      { id: "1", title: "Document 1" },
      { id: "2", title: "Document 2" },
    ];

    // Mock API response
    jest.spyOn(global, "fetch").mockResolvedValueOnce({
      ok: true,
      json: async () => mockDocuments,
    } as Response);

    const { result } = renderHook(() => useDocuments(), {
      wrapper: TestWrapper,
    });

    await waitFor(() => {
      expect(result.current.documents).toEqual(mockDocuments);
    });
  });
});
```

## Performance Optimization

1. **Use React.memo for expensive components**
2. **Use useMemo for expensive calculations**
3. **MANDATORY: Use useRefCallback instead of useCallback for stable references**
4. **Implement lazy loading for routes and components**
5. **Use proper key props for lists**
6. **Avoid unnecessary re-renders**
7. **Use React DevTools Profiler**
8. **Implement proper code splitting**
9. **Optimize bundle size**
10. **Use proper image optimization**

## Unit Testing Patterns

**MANDATORY: Use Vitest + React Testing Library for all unit tests. This is the standard testing stack for the project.**

Use this guide as the definitive reference for all code generation and development work on this project.
