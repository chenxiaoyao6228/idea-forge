---
description: React Client Code Style Guide for Idea Forge
globs: ["apps/client/**/*.tsx"]
alwaysApply: false
---

# React Client Code Style Guide for Idea Forge

This document serves as the definitive guide for code style, patterns, and conventions used in the Idea Forge React client. This guide should be used as context for all future code generation and development work.

## Table of Contents

- [Project Overview](mdc:#project-overview)
- [General TypeScript Guidelines](mdc:#general-typescript-guidelines)
- [File and Directory Structure](mdc:#file-and-directory-structure)
- [Component Architecture](mdc:#component-architecture)
- [State Management](mdc:#state-management)
- [Hooks and Custom Hooks](mdc:#hooks-and-custom-hooks)
- [Styling and UI](mdc:#styling-and-ui)
- [API Integration](mdc:#api-integration)
- [Routing](mdc:#routing)
- [Testing Patterns](mdc:#testing-patterns)
- [Performance Optimization](mdc:#performance-optimization)
- [Modal Management](mdc:#modal-management)

## Project Overview

This is a modern Notion-like note taking React application built with:

- **React 18.x** - UI library with concurrent features
- **TypeScript 5.x** - Strict type checking enabled
- **Vite** - Fast build tool and dev server
- **React Router** - Client-side routing
- **React Use** - Primitive react hook sets
- **@ahooksjs/use-request** - Async request management
- **Zustand** - Lightweight state management
- **TipTap** - Rich text editor with collaboration
- **Yjs** - Real-time collaboration
- **Shadcn UI** - Component library built on Radix
- **Tailwind CSS** - Utility-first CSS framework
- **Socket.io** - Websocket lib
- **Class Variance Authority (CVA)** - Component variant management
- **Lucide React** - Icon library
- **Vitest** - Testing framework
- **react-confirm** - Modal and confirmation dialog management

## General TypeScript Guidelines

### Basic Principles

- Use English for all code and documentation
- Always declare types for variables and functions (avoid `any`)
- Use strict TypeScript configuration
- Use functional and declarative programming patterns
- Avoid classes; prefer functions and hooks
- Use descriptive variable names with auxiliary verbs (e.g., `isLoading`, `hasError`)
- Favor iteration and modularization over duplication (DRY principles)

### Naming Conventions

```typescript
// PascalCase for components, interfaces, types
export interface UserProps {}
export type UserStatus = "active" | "inactive";
export function UserCard() {}

// camelCase for variables, functions, methods
const userName = "john";

// kebab-case for files and directories
'user-data.ts";

// UPPERCASE for constants
const MAX_RETRY_ATTEMPTS = 3;
const API_ENDPOINTS = {
  USERS: "/api/users",
  DOCUMENTS: "/api/documents",
} as const;

// Use verbs for boolean variables
const isLoading = true;
const hasError = false;
const canDelete = user.role === "admin";
// use verb for action
const checkStar = ()=> {}
```

### TypeScript Conventions

```typescript
// Use interfaces for object shapes
interface User {
  id: string;
  email: string;
  firstName: string;
  lastName: string;
  role: UserRole;
}

// Use type aliases for unions and complex types
type UserStatus = "active" | "inactive" | "pending";
type ApiResponse<T> = { data: T; message: string };

// Use generic types for reusable components
interface ListProps<T> {
  items: T[];
  renderItem: (item: T) => React.ReactNode;
  keyExtractor: (item: T) => string;
}

// Use proper typing for event handlers
const handleSubmit = (event: React.FormEvent<HTMLFormElement>) => {
  event.preventDefault();
  // handle form submission
};
```

## File and Directory Structure

### Project Structure

```
apps/client/src/
├── main.tsx                    # Application entry point
├── App.tsx                     # Root component
├── index.css                   # Global styles
├── vite-env.d.ts              # Vite type definitions
├── components/                 # Reusable components
│   ├── ui/                     # Base UI components (Shadcn)
│   │   ├── button.tsx
│   │   ├── input.tsx
│   │   └── dialog.tsx
│   ├── editor/                 # TipTap editor components
│   └── collaboration/          # Collaboration components
├── pages/                      # Page components
│   ├── auth/
│   ├── dashboard/
│   ├── documents/
│   └── settings/
├── hooks/                      # Custom hooks
│   ├── use-auth.ts
│   ├── use-documents.ts
│   └── use-collaboration.ts
├── stores/                     # Zustand stores
│   ├── auth.ts
│   ├── document.ts
│   └── ui.ts
├── lib/                        # Utility libraries
│   ├── api.ts
│   ├── utils.ts
│   ├── constants.ts
│   └── validations.ts
├── types/                      # TypeScript type definitions
│   ├── user.ts
│   ├── document.ts
│   └── api.ts
├── router/                     # Routing configuration
│   ├── routes.tsx
│   └── guards.tsx
├── constants/                  # Application constants
├── assets/                     # Static assets
└── hocs/                       # Higher-order components
```

### Component Structure

Each component follows this structure:

```
components/feature-name/
├── feature-name.tsx            # Main component
├── feature-name.types.ts       # Component types(if too many types exported from the component)
└── index.ts                    # Barrel export
```

### File Naming Conventions

- Use kebab-case: `user-card.tsx`
- Use descriptive names: `document-editor.tsx`, `collaboration-cursor.tsx`
- Include type in filename: `.types.ts`, `.store.ts`, `.hook.ts`
- Use singular names for components: `user-card.tsx` not `user-cards.tsx`

## Component Architecture

### Separation of UI and Logic

**MANDATORY: Components MUST separate UI rendering from business logic. Business logic should be encapsulated in stores, custom hooks, or utility functions.**

#### ✅ Correct Pattern - Logic in Store

```typescript
// Store handles all business logic
const useStarStore = create<StarStoreState>()((set, get) => ({
  // ... other state and actions

  // Business logic method
  getNavigationNodeForStar: (star) => {
    // Complex logic for finding navigation nodes
    // across different data sources
    if (star.subspaceId) {
      const subspace = useSubSpaceStore.getState().entities[star.subspaceId];
      if (!subspace) return null;
      return {
        id: subspace.id,
        title: subspace.name,
        type: NavigationNodeType.Subspace,
        url: `/subspace/${subspace.id}`,
        children: subspace.navigationTree || [],
        parent: null,
      };
    }

    // More complex logic...
    return null;
  },
}));

// Component only handles UI rendering
export function StarLink({ star }: StarLinkProps) {
  const getNavigationNodeForStar = useStarStore(
    (state) => state.getNavigationNodeForStar
  );

  // Simple UI logic only
  const navigationNode = useMemo(() => {
    return getNavigationNodeForStar(star);
  }, [star, getNavigationNodeForStar]);

  if (!navigationNode) return null;

  return (
    <div className="star-link">
      <SidebarLink
        to={navigationNode.url || `/${navigationNode.id}`}
        icon={<StarIcon className="h-4 w-4 text-yellow-500" />}
        label={navigationNode.title}
        // ... other UI props
      />
    </div>
  );
}
```

#### ❌ Incorrect Pattern - Logic in Component

```typescript
// ❌ DON'T: Complex business logic in component
export function StarLink({ star }: StarLinkProps) {
  const [isLoading, setIsLoading] = useState(false);
  const document = useDocumentStore((state) => state.entities[star.docId || ""]);
  const subspace = useSubSpaceStore((state) => state.entities[star.subspaceId || ""]);
  const sharedDocuments = useSharedWithMeStore((state) => state.documents);

  // ❌ Complex business logic in component
  const findNavigationNode = useCallback((docId: string, nodes: NavigationNode[]): NavigationNode | null => {
    for (const node of nodes) {
      if (node.id === docId) {
        return node;
      }
      if (node.children) {
        const found = findNavigationNode(docId, node.children);
        if (found) return found;
      }
    }
    return null;
  }, []);

  // ❌ More complex logic...
  const navigationNode = useMemo(() => {
    if (!star.docId) return null;

    // Check subspace navigation tree
    if (subspace?.navigationTree) {
      const found = findNavigationNode(star.docId, subspace.navigationTree);
      if (found) return found;
    }

    // Check personal subspace...
    // Check shared documents...
    // etc...
  }, [star.docId, subspace, findNavigationNode]);

  // ❌ Data fetching logic in component
  useEffect(() => {
    if (star.docId && !document && !isLoading) {
      setIsLoading(true);
      fetchDocumentDetail(star.docId, { silent: true })
        .catch((error) => {
          console.warn(`Failed to fetch document ${star.docId}:`, error);
        })
        .finally(() => {
          setIsLoading(false);
        });
    }
  }, [star.docId, document, isLoading, fetchDocumentDetail]);

  // Component is now bloated with business logic
  return (
    // ... UI rendering
  );
}
```

#### Separation Principles

1. **Store Methods**: Complex business logic should be in store methods
2. **Custom Hooks**: Reusable logic should be in custom hooks
3. **Utility Functions**: Pure functions should be in utility modules
4. **Component Focus**: Components should only handle UI rendering and simple state
5. **Single Responsibility**: Each layer should have a single, clear responsibility

### Functional Component Pattern

1. **Use functional components with hooks**
2. **Use TypeScript interfaces for props**
3. **Use descriptive prop names**
4. **Handle loading and error states**
5. **Use proper event handling**
6. **Implement proper accessibility** d
7. **Use composition over inheritance**
8. **Keep components focused and single-purpose**
9. **Use proper error boundaries**
10. **Implement proper cleanup in useEffect**
11. **MANDATORY: Separate UI from business logic** - Components should only handle UI rendering, not complex business logic
12. **Encapsulate business logic in stores or custom hooks** - Keep components clean and focused on presentation
13. **Avoid data fetching in components** - Use stores or custom hooks for data management
14. **Minimize component complexity** - If a component has too much logic, extract it to a store or hook

### Modal Management

**MANDATORY: All modal dialogs, confirmations, and popups MUST use `react-confirm` library. Do NOT use native browser `confirm()`, `alert()`, or custom modal implementations.**

for simple confirmation, use the predefined custom confirm modal

```ts
// import
import { showConfirmModal } from "@/components/ui/confirm-modal";
// usage
showConfirmModal({
  type: "alert",
  confirmVariant: "destructive",
  title: t("Permanent Delete"),
  description: t(
    "Are you sure you want to permanently delete this document? This action cannot be undone."
  ),
  confirmText: t("Delete"),
  cancelText: t("Cancel"),
  onConfirm: async () => {
    try {
      await documentApi.permanentDelete(id);
      await loadTrashDocuments();
      toast.success(t("Document deleted permanently"));
      return true;
    } catch (error: any) {
      if (error?.code === ErrorCodeEnum.DocumentNotFound) {
        // refresh trash documents
        toast.error(t("Document not found in trash"));
        await loadTrashDocuments();
        return false;
      }
      toast.error(t("Failed to delete document"));
      return false;
    }
  },
});
```

## State Management

### Hook-Based Store Architecture

**MANDATORY: Use the new hook-based architecture for all state management. This provides better developer experience, maintainability, and WebSocket compatibility.**

#### Architecture Principles

1. **Minimal Store**: Only state and basic mutations
2. **Root-level CRUD Hooks**: Individual hooks for each operation
3. **Custom useRequest**: Handle loading states automatically
4. **Clean Computed Values**: Use React's `useMemo`
5. **WebSocket Compatible**: Direct store mutations work seamlessly
6. **Separation of Concerns**: UI logic separate from business logic

#### Store Structure Pattern

```typescript
// ✅ Minimal store - just state and basic mutations
const useStarStore = create<{
  stars: StarEntity[];
  setStars: (stars: StarEntity[]) => void;
  addStar: (star: StarEntity) => void;
  updateStar: (id: string, changes: Partial<StarEntity>) => void;
  removeStar: (id: string) => void;
}>((set) => ({
  stars: [],

  setStars: (stars) => set({ stars }),

  addStar: (star) =>
    set((state) => ({
      stars: [...state.stars, star],
    })),

  updateStar: (id, changes) =>
    set((state) => ({
      stars: state.stars.map((star) =>
        star.id === id ? { ...star, ...changes } : star
      ),
    })),

  removeStar: (id) =>
    set((state) => ({
      stars: state.stars.filter((star) => star.id !== id),
    })),
}));
```

#### Individual CRUD Hooks Pattern

```typescript
// ✅ Data access hook with computed values
export const useStars = () => {
  const { stars } = useStarStore();

  const orderedStars = useMemo(
    () => stars.sort((a, b) => (a.index || "").localeCompare(b.index || "")),
    [stars]
  );

  const starsBySubspace = useMemo(() => groupBy(stars, "subspaceId"), [stars]);

  const isStarred = useCallback(
    (docId?: string, subspaceId?: string) => {
      return stars.some(
        (star) =>
          (docId && star.docId === docId) ||
          (subspaceId && star.subspaceId === subspaceId)
      );
    },
    [stars]
  );

  return {
    stars,
    orderedStars,
    starsBySubspace,
    isStarred,
  };
};

// ✅ Fetch operation
export const useFetchStars = () => {
  const { setStars } = useStarStore();
  const currentWorkspace = useWorkspaceStore((s) => s.currentWorkspace);
  const toast = useToast();

  return useRequest(() => starApi.findAll(currentWorkspace.id), {
    onSuccess: (response) => setStars(response.data.stars),
    onError: (error) =>
      toast.error("Failed to fetch stars", {
        description: error.message,
      }),
    enabled: !!currentWorkspace,
  });
};

// ✅ Create operation
export const useCreateStar = () => {
  const { addStar } = useStarStore();
  const toast = useToast();

  return useRequest((params: CreateStarDto) => starApi.create(params), {
    onSuccess: (response) => {
      addStar(response.data);
      toast.success("Star created");
    },
    onError: (error) =>
      toast.error("Failed to create star", {
        description: error.message,
      }),
  });
};

// ✅ High-level hook that combines operations
export const useStarActions = (docId?: string, subspaceId?: string) => {
  const { isStarred, findStar } = useStars();
  const { execute: createStar, isLoading: isCreating } = useCreateStar();
  const { execute: deleteStar, isLoading: isDeleting } = useDeleteStar();

  const starred = isStarred(docId, subspaceId);

  const toggleStar = useRefCallback(async () => {
    if (starred) {
      const star = findStar(docId, subspaceId);
      if (star) await deleteStar(star.id);
    } else {
      await createStar({ docId, subspaceId });
    }
  });

  return {
    isStarred: starred,
    toggleStar,
    isLoading: isCreating || isDeleting,
  };
};
```

### Zustand Store Pattern

**Only type the interface/type for store state and actions. Do NOT add explicit parameter types to the implementation of store functions.**

For example, this is correct:

```typescript
interface UserStoreState {
  loading: boolean;
  userInfo: UserInfo | null;
  setUserInfo: (userInfo: UserInfo) => void;
}

const useUserStore = create<UserStoreState>()((set) => ({
  loading: false,
  userInfo: null,
  setUserInfo: (userInfo) => set({ userInfo }), // no explicit type here
  logout: async () => {
    set({ loading: true });
    await authApi.logout();
    localStorage.clear();
    set({ userInfo: null, loading: false });
  },
}));
```

**Do NOT do this:**

```typescript
const useUserStore = create<UserStoreState>()((set) => ({
  setUserInfo: (userInfo: UserInfo) => set({ userInfo }), // ❌ Don't type here
}));
```

- Type the interface/type for state and actions.
- Do NOT type the implementation parameters.
- This keeps the implementation concise and leverages TypeScript inference from the interface.

### State Management Best Practices

#### DO ✅

1. **Create minimal stores with only state and mutations**

   ```typescript
   // ✅ Good
   const useStarStore = create<{
     stars: StarEntity[];
     setStars: (stars: StarEntity[]) => void;
     addStar: (star: StarEntity) => void;
   }>((set) => ({
     /* ... */
   }));
   ```

2. **Use individual hooks for each CRUD operation**

   ```typescript
   // ✅ Good
   const useCreateStar = () => {
     /* ... */
   };
   const useUpdateStar = () => {
     /* ... */
   };
   const useDeleteStar = () => {
     /* ... */
   };
   ```

3. **Use useMemo for computed values**

   ```typescript
   // ✅ Good
   const orderedStars = useMemo(
     () => stars.sort((a, b) => a.index.localeCompare(b.index)),
     [stars]
   );
   ```

4. **Handle errors with toast in hooks**

   ```typescript
   // ✅ Good
   return useRequest(apiCall, {
     onError: (error) =>
       toast.error("Operation failed", {
         description: error.message,
       }),
   });
   ```

5. **Use `useRefCallback` for stable references**

   ```typescript
   // ✅ Good
   const handleAction = useRefCallback(async () => {
     // This always has latest closure values
   });
   ```

6. **Separate UI from logic with action hooks**

   ```typescript
   // ✅ Good - Logic in hook
   const useStarActions = (docId, subspaceId) => {
     return { isStarred, toggleStar, isLoading };
   };

   // ✅ Good - UI only
   function StarButton({ docId, subspaceId }) {
     const { isStarred, toggleStar, isLoading } = useStarActions(
       docId,
       subspaceId
     );
     return (
       <Button onClick={toggleStar}>{isStarred ? "Unstar" : "Star"}</Button>
     );
   }
   ```

#### DON'T ❌

1. **Don't put API logic in stores**

   ```typescript
   // ❌ Bad
   const useStore = create((set) => ({
     fetchData: async () => {
       set({ isLoading: true });
       try {
         const data = await api.fetch();
         set({ data, isLoading: false });
       } catch (error) {
         // ... error handling
       }
     },
   }));
   ```

2. **Don't use entity slice patterns**

   ```typescript
   // ❌ Bad
   const entity = store.entities[id];
   ```

3. **Don't use createComputed for complex computations**

   ```typescript
   // ❌ Bad
   createComputed((state) => ({
     complexComputation: heavyCalculation(state),
   }));
   ```

4. **Don't handle errors with console.log**

   ```typescript
   // ❌ Bad
   catch (error) {
     console.error("Something failed:", error);
   }
   ```

5. **Don't use React Query with direct WebSocket mutations**

   ```typescript
   // ❌ Bad - creates cache conflicts
   const query = useQuery(["data"], fetchData);
   socket.on("update", (data) => {
     // This conflicts with React Query cache
     updateStore(data);
   });
   ```

6. **Don't put business logic in components**

   ```typescript
   // ❌ Bad - Logic mixed with UI
   function StarButton({ docId, subspaceId }) {
     const [isLoading, setIsLoading] = useState(false);
     const handleClick = async () => {
       setIsLoading(true);
       try {
         // Complex business logic here...
       } catch (error) {
         toast.error("Failed");
       }
       setIsLoading(false);
     };
   }
   ```

### Store Best Practices

1. **Use Zustand for client state management**
2. **Use devtools middleware for debugging**
3. **Separate state and actions clearly**
4. **Handle loading and error states**
5. **Use proper TypeScript typing**
6. **Implement proper error handling**
7. **Use localStorage for persistence when needed**
8. **Keep stores focused and single-purpose**
9. **MANDATORY: Use hook-based architecture for all new stores**
10. **MANDATORY: Separate UI logic from business logic**
11. **MANDATORY: Use individual CRUD hooks for each operation**
12. **MANDATORY: Use useRequest for automatic loading state management**

## Hooks and Custom Hooks

### Hook Library Strategy

**MANDATORY: Use react-use for basic functionality, @ahooksjs/use-request for async operations, and useRefCallback for stable function references.**

```typescript
// ✅ useRefCallback implementation
import { useRef, useCallback } from "react";

export function useRefCallback<T extends (...args: any[]) => any>(fn: T): T {
  const fnRef = useRef(fn);
  fnRef.current = fn;
  return useCallback(
    (...args: Parameters<T>) => fnRef.current(...args),
    []
  ) as T;
}
```

### useRequest Pattern

**MANDATORY: Use @ahooksjs/use-request for all async operations. It provides automatic loading states, error handling, and caching.**

```typescript
import useRequest from "@ahooksjs/use-request";

// ✅ Basic usage
const { data, loading, error, run } = useRequest(
  async () => {
    const response = await api.getData();
    return response.data;
  },
  {
    onSuccess: (data) => {
      toast.success("Data loaded successfully");
    },
    onError: (error) => {
      toast.error("Failed to load data", {
        description: error.message,
      });
    },
  }
);

// ✅ Manual trigger
const { data, loading, error, run } = useRequest(
  async (params: CreateParams) => {
    const response = await api.create(params);
    return response.data;
  },
  {
    manual: true, // Don't auto-trigger
    onSuccess: (data) => {
      toast.success("Created successfully");
    },
  }
);

// ✅ Conditional execution
const { data, loading, error } = useRequest(
  async () => {
    const response = await api.getData();
    return response.data;
  },
  {
    ready: !!userId, // Only run when userId exists
    refreshDeps: [userId], // Re-run when userId changes
  }
);

// ✅ Pagination
const { data, loading, error, run } = useRequest(
  async (page: number) => {
    const response = await api.getData({ page, limit: 25 });
    return response.data;
  },
  {
    manual: true,
    onSuccess: (result) => {
      if (result.page === 1) {
        setAllData(result.data);
      } else {
        setAllData((prev) => [...prev, ...result.data]);
      }
    },
  }
);
```

### Custom Hook Patterns

#### State Management Hooks

```typescript
// ✅ Toggle hook with stable reference
export function useToggle<T>(initialValue: T, alternateValue: T) {
  const [state, setState] = useState(initialValue);

  const toggle = useRefCallback(() => {
    setState((current) =>
      current === initialValue ? alternateValue : initialValue
    );
  });

  return [state, toggle] as const;
}

// ✅ Counter hook
export function useCounter(initialValue: number = 0) {
  const [count, setCount] = useState(initialValue);

  const increment = useRefCallback(() => setCount((prev) => prev + 1));
  const decrement = useRefCallback(() => setCount((prev) => prev - 1));
  const reset = useRefCallback(() => setCount(initialValue));

  return { count, increment, decrement, reset };
}
```

#### Async Operation Hooks

```typescript
// ✅ Async operation hook
export function useAsyncOperation<T, P extends any[]>(
  asyncFn: (...args: P) => Promise<T>
) {
  const [data, setData] = useState<T | null>(null);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<Error | null>(null);

  const execute = useRefCallback(async (...args: P) => {
    setLoading(true);
    setError(null);
    try {
      const result = await asyncFn(...args);
      setData(result);
      return result;
    } catch (err) {
      const error = err instanceof Error ? err : new Error(String(err));
      setError(error);
      throw error;
    } finally {
      setLoading(false);
    }
  });

  return { data, loading, error, execute };
}
```

#### Event Handler Hooks

```typescript
// ✅ Debounced callback
export function useDebouncedCallback<T extends (...args: any[]) => any>(
  callback: T,
  delay: number
): T {
  const timeoutRef = useRef<NodeJS.Timeout>();

  const debouncedCallback = useRefCallback((...args: Parameters<T>) => {
    if (timeoutRef.current) clearTimeout(timeoutRef.current);
    timeoutRef.current = setTimeout(() => callback(...args), delay);
  });

  useEffect(
    () => () => {
      if (timeoutRef.current) clearTimeout(timeoutRef.current);
    },
    []
  );

  return debouncedCallback as T;
}
```

### Hook Best Practices

#### DO ✅

1. **Use useRefCallback for all function references**
2. **Use react-use for basic functionality**
3. **Use @ahooksjs/use-request for async operations**
4. **Keep hooks focused and single-purpose**
5. **Handle cleanup in useEffect**
6. **Return stable references**

#### DON'T ❌

1. **Don't use useCallback for function references**
2. **Don't use TanStack Query - use @ahooksjs/use-request instead**
3. **Don't forget cleanup in useEffect**
4. **Don't return unstable references**
5. **Don't use hooks inside conditions or loops**

## Styling and UI

1. **Use Shadcn UI components as base**
2. **Use Radix UI for accessibility**
3. **Use Tailwind CSS for styling**
4. **Use CVA for component variants**
5. **Implement responsive design**
6. **Support dark mode**
7. **Use proper spacing and typography**
8. **Implement proper accessibility**
9. **Use consistent design tokens**
10. **Follow mobile-first approach**

## API Integration

### API Client Pattern

```typescript
// use contracts from packages/contract, if have no one, please define them in that folder
import type { ListDocumentResponse, ListDocumentDto } from "@idea/contracts";
// API functions
export const documentApi = {
  list: async (data: ListDocumentDto) => {
    return request.post<ListDocumentDto, ListDocumentResponse>(
      `/api/documents/list`,
      data
    );
  },
};
```

## Routing

### Route Configuration Pattern

```typescript
import React from "react";
import { createBrowserRouter, Navigate } from "react-router-dom";
import { Layout } from "@/components/layout/layout";
import { AuthGuard } from "@/router/guards";
import { LoginPage } from "@/pages/auth/login-page";
import { DashboardPage } from "@/pages/dashboard/dashboard-page";
import { DocumentPage } from "@/pages/documents/document-page";
import { SettingsPage } from "@/pages/settings/settings-page";

export const router = createBrowserRouter([
  {
    path: "/",
    element: <Layout />,
    children: [
      {
        index: true,
        element: <Navigate to="/dashboard" replace />,
      },
      {
        path: "login",
        element: <LoginPage />,
      },
      {
        path: "dashboard",
        element: (
          <AuthGuard>
            <DashboardPage />
          </AuthGuard>
        ),
      },
      {
        path: "documents/:id",
        element: (
          <AuthGuard>
            <DocumentPage />
          </AuthGuard>
        ),
      },
      {
        path: "settings",
        element: (
          <AuthGuard>
            <SettingsPage />
          </AuthGuard>
        ),
      },
    ],
  },
]);
```

### Route Guard Pattern

```typescript
import React from "react";
import { Navigate, useLocation } from "react-router-dom";
import { useAuthStore } from "@/stores/auth-store";

interface AuthGuardProps {
  children: React.ReactNode;
}

export function AuthGuard({ children }: AuthGuardProps) {
  const { user, isLoading } = useAuthStore();
  const location = useLocation();

  if (isLoading) {
    return <div>Loading...</div>;
  }

  if (!user) {
    return <Navigate to="/login" state={{ from: location }} replace />;
  }

  return <>{children}</>;
}
```

### Hook Test Pattern

```typescript
import { renderHook, waitFor } from "@testing-library/react";
import { QueryClient, QueryClientProvider } from "@tanstack/react-query";
import { useDocuments } from "./use-documents";

const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      retry: false,
    },
  },
});

const TestWrapper = ({ children }: { children: React.ReactNode }) => (
  <QueryClientProvider client={queryClient}>{children}</QueryClientProvider>
);

describe("useDocuments", () => {
  it("fetches documents successfully", async () => {
    const mockDocuments = [
      { id: "1", title: "Document 1" },
      { id: "2", title: "Document 2" },
    ];

    // Mock API response
    jest.spyOn(global, "fetch").mockResolvedValueOnce({
      ok: true,
      json: async () => mockDocuments,
    } as Response);

    const { result } = renderHook(() => useDocuments(), {
      wrapper: TestWrapper,
    });

    await waitFor(() => {
      expect(result.current.documents).toEqual(mockDocuments);
    });
  });
});
```

## Performance Optimization

1. **Use React.memo for expensive components**
2. **Use useMemo for expensive calculations**
3. **MANDATORY: Use useRefCallback instead of useCallback for stable references**
4. **Implement lazy loading for routes and components**
5. **Use proper key props for lists**
6. **Avoid unnecessary re-renders**
7. **Use React DevTools Profiler**
8. **Implement proper code splitting**
9. **Optimize bundle size**
10. **Use proper image optimization**

## Testing Patterns

TODO:

Use this guide as the definitive reference for all code generation and development work on this project.
