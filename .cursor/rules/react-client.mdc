---
description: React Client Code Style Guide for Idea Forge
globs: ["apps/client/**/*.tsx"]
alwaysApply: false
---

# React Client Code Style Guide for Idea Forge

This document serves as the definitive guide for code style, patterns, and conventions used in the Idea Forge React client. This guide should be used as context for all future code generation and development work.

## Table of Contents

- [Project Overview](mdc:#project-overview)
- [General TypeScript Guidelines](mdc:#general-typescript-guidelines)
- [File and Directory Structure](mdc:#file-and-directory-structure)
- [Component Architecture](mdc:#component-architecture)
- [State Management](mdc:#state-management)
- [Hooks and Custom Hooks](mdc:#hooks-and-custom-hooks)
- [Styling and UI](mdc:#styling-and-ui)
- [API Integration](mdc:#api-integration)
- [Routing](mdc:#routing)
- [Testing Patterns](mdc:#testing-patterns)
- [Performance Optimization](mdc:#performance-optimization)
- [Modal Management](mdc:#modal-management)
- [Code Quality and Linting](mdc:#code-quality-and-linting)

## Project Overview

This is a modern React application built with:

- **React 18.x** - UI library with concurrent features
- **TypeScript 5.x** - Strict type checking enabled
- **Vite** - Fast build tool and dev server
- **React Router** - Client-side routing
- **Zustand** - Lightweight state management
- **TanStack Query** - Server state management
- **TipTap** - Rich text editor with collaboration
- **Yjs** - Real-time collaboration
- **Radix UI** - Accessible component primitives
- **Shadcn UI** - Component library built on Radix
- **Tailwind CSS** - Utility-first CSS framework
- **Class Variance Authority (CVA)** - Component variant management
- **Lucide React** - Icon library
- **Vitest** - Testing framework
- **Biome** - Code formatting and linting
- **react-confirm** - Modal and confirmation dialog management

## General TypeScript Guidelines

### Basic Principles

- Use English for all code and documentation
- Always declare types for variables and functions (avoid `any`)
- Use strict TypeScript configuration
- Use functional and declarative programming patterns
- Avoid classes; prefer functions and hooks
- Use descriptive variable names with auxiliary verbs (e.g., `isLoading`, `hasError`)
- Favor iteration and modularization over duplication (DRY principles)

### Naming Conventions

```typescript
// PascalCase for components, interfaces, types
export interface UserProps {}
export type UserStatus = "active" | "inactive";
export function UserCard() {}

// camelCase for variables, functions, methods
const userName = "john";
function createUser() {}
const isLoading = true;

// kebab-case for files and directories
user - card.tsx;
use - user - data.ts;
user - settings.ts;

// UPPERCASE for constants
const MAX_RETRY_ATTEMPTS = 3;
const API_ENDPOINTS = {
  USERS: "/api/users",
  DOCUMENTS: "/api/documents",
} as const;

// Use verbs for boolean variables
const isLoading = true;
const hasError = false;
const canDelete = user.role === "admin";
```

### Import Organization

```typescript
// 1. React and external libraries
import React, { useState, useEffect } from "react";
import { useNavigate } from "react-router-dom";
import { Button } from "@/components/ui/button";

// 2. Internal imports with absolute paths
import { useUserStore } from "@/stores/user-store";
import { api } from "@/lib/api";
import type { User } from "@/types/user";

// 3. Relative imports
import { UserCard } from "./user-card";
import { useUserData } from "./hooks/use-user-data";
```

### TypeScript Conventions

```typescript
// Use interfaces for object shapes
interface User {
  id: string;
  email: string;
  firstName: string;
  lastName: string;
  role: UserRole;
}

// Use type aliases for unions and complex types
type UserStatus = "active" | "inactive" | "pending";
type ApiResponse<T> = { data: T; message: string };

// Use generic types for reusable components
interface ListProps<T> {
  items: T[];
  renderItem: (item: T) => React.ReactNode;
  keyExtractor: (item: T) => string;
}

// Use proper typing for event handlers
const handleSubmit = (event: React.FormEvent<HTMLFormElement>) => {
  event.preventDefault();
  // handle form submission
};

const handleInputChange = (event: React.ChangeEvent<HTMLInputElement>) => {
  const { value } = event.target;
  // handle input change
};
```

## File and Directory Structure

### Project Structure

```
apps/client/src/
├── main.tsx                    # Application entry point
├── App.tsx                     # Root component
├── index.css                   # Global styles
├── vite-env.d.ts              # Vite type definitions
├── components/                 # Reusable components
│   ├── ui/                     # Base UI components (Shadcn)
│   │   ├── button.tsx
│   │   ├── input.tsx
│   │   └── dialog.tsx
│   ├── layout/                 # Layout components
│   │   ├── header.tsx
│   │   ├── sidebar.tsx
│   │   └── footer.tsx
│   ├── forms/                  # Form components
│   ├── editor/                 # TipTap editor components
│   └── collaboration/          # Collaboration components
├── pages/                      # Page components
│   ├── auth/
│   ├── dashboard/
│   ├── documents/
│   └── settings/
├── hooks/                      # Custom hooks
│   ├── use-auth.ts
│   ├── use-documents.ts
│   └── use-collaboration.ts
├── stores/                     # Zustand stores
│   ├── auth.ts
│   ├── document.ts
│   └── ui.ts
├── lib/                        # Utility libraries
│   ├── api.ts
│   ├── utils.ts
│   ├── constants.ts
│   └── validations.ts
├── types/                      # TypeScript type definitions
│   ├── user.ts
│   ├── document.ts
│   └── api.ts
├── router/                     # Routing configuration
│   ├── routes.tsx
│   └── guards.tsx
├── constants/                  # Application constants
├── assets/                     # Static assets
└── hocs/                       # Higher-order components
```

### Component Structure

Each component follows this structure:

```
components/feature-name/
├── feature-name.tsx            # Main component
├── feature-name.types.ts       # Component types(if too many types exported from the component)
└── index.ts                    # Barrel export
```

### File Naming Conventions

- Use kebab-case: `user-card.tsx`
- Use descriptive names: `document-editor.tsx`, `collaboration-cursor.tsx`
- Include type in filename: `.types.ts`, `.store.ts`, `.hook.ts`
- Use singular names for components: `user-card.tsx` not `user-cards.tsx`

## Component Architecture

### Functional Component Pattern

```typescript
import React, { useState, useEffect } from "react";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { useUserStore } from "@/stores/user-store";
import { api } from "@/lib/api";
import { confirm } from "react-confirm";
import type { User } from "@/types/user";

interface UserCardProps {
  user: User;
  onEdit?: (user: User) => void;
  onDelete?: (userId: string) => void;
}

export function UserCard({ user, onEdit, onDelete }: UserCardProps) {
  const [isLoading, setIsLoading] = useState(false);
  const { currentUser } = useUserStore();

  const handleDelete = async () => {
    const confirmed = await confirm({
      title: "Delete User",
      message:
        "Are you sure you want to delete this user? This action cannot be undone.",
      confirmText: "Delete",
      cancelText: "Cancel",
      variant: "destructive",
    });

    if (!confirmed) {
      return;
    }

    setIsLoading(true);
    try {
      await api.delete(`/users/${user.id}`);
      onDelete?.(user.id);
    } catch (error) {
      console.error("Failed to delete user:", error);
    } finally {
      setIsLoading(false);
    }
  };

  return (
    <div className="p-4 border rounded-lg shadow-sm">
      <div className="flex items-center justify-between">
        <div>
          <h3 className="text-lg font-semibold">
            {user.firstName} {user.lastName}
          </h3>
          <p className="text-sm text-gray-600">{user.email}</p>
        </div>
        <div className="flex gap-2">
          {onEdit && (
            <Button variant="outline" size="sm" onClick={() => onEdit(user)}>
              Edit
            </Button>
          )}
          {onDelete && currentUser?.role === "admin" && (
            <Button
              variant="destructive"
              size="sm"
              onClick={handleDelete}
              disabled={isLoading}
            >
              {isLoading ? "Deleting..." : "Delete"}
            </Button>
          )}
        </div>
      </div>
    </div>
  );
}
```

### Component Best Practices

1. **Use functional components with hooks**
2. **Use TypeScript interfaces for props**
3. **Use descriptive prop names**
4. **Handle loading and error states**
5. **Use proper event handling**
6. **Implement proper accessibility**
7. **Use composition over inheritance**
8. **Keep components focused and single-purpose**
9. **Use proper error boundaries**
10. **Implement proper cleanup in useEffect**

## State Management

### Zustand Store Pattern

**Only type the interface/type for store state and actions. Do NOT add explicit parameter types to the implementation of store functions.**

For example, this is correct:

```typescript
interface UserStoreState {
  loading: boolean;
  userInfo: UserInfo | null;
  setUserInfo: (userInfo: UserInfo) => void;
}

const useUserStore = create<UserStoreState>()((set) => ({
  loading: false,
  userInfo: null,
  setUserInfo: (userInfo) => set({ userInfo }), // no explicit type here
  logout: async () => {
    set({ loading: true });
    await authApi.logout();
    localStorage.clear();
    set({ userInfo: null, loading: false });
  },
}));
```

**Do NOT do this:**

```typescript
const useUserStore = create<UserStoreState>()((set) => ({
  setUserInfo: (userInfo: UserInfo) => set({ userInfo }), // ❌ Don't type here
}));
```

- Type the interface/type for state and actions.
- Do NOT type the implementation parameters.
- This keeps the implementation concise and leverages TypeScript inference from the interface.

### Store Best Practices

1. **Use Zustand for client state management**
2. **Use devtools middleware for debugging**
3. **Separate state and actions clearly**
4. **Handle loading and error states**
5. **Use proper TypeScript typing**
6. **Implement proper error handling**
7. **Use localStorage for persistence when needed**
8. **Keep stores focused and single-purpose**

## Hooks and Custom Hooks

### Custom Hook Pattern

```typescript
import { useState, useEffect, useCallback } from "react";
import { useQuery, useMutation, useQueryClient } from "@tanstack/react-query";
import { api } from "@/lib/api";
import type {
  Document,
  CreateDocumentDto,
  UpdateDocumentDto,
} from "@/types/document";

export function useDocuments() {
  const queryClient = useQueryClient();

  // Query for fetching documents
  const {
    data: documents,
    isLoading,
    error,
    refetch,
  } = useQuery({
    queryKey: ["documents"],
    queryFn: async () => {
      const response = await api.get("/documents");
      return response.data as Document[];
    },
  });

  // Mutation for creating documents
  const createDocumentMutation = useMutation({
    mutationFn: async (data: CreateDocumentDto) => {
      const response = await api.post("/documents", data);
      return response.data as Document;
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ["documents"] });
    },
  });

  // Mutation for updating documents
  const updateDocumentMutation = useMutation({
    mutationFn: async ({
      id,
      data,
    }: {
      id: string;
      data: UpdateDocumentDto;
    }) => {
      const response = await api.put(`/documents/${id}`, data);
      return response.data as Document;
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ["documents"] });
    },
  });

  // Mutation for deleting documents
  const deleteDocumentMutation = useMutation({
    mutationFn: async (id: string) => {
      await api.delete(`/documents/${id}`);
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ["documents"] });
    },
  });

  return {
    documents,
    isLoading,
    error,
    refetch,
    createDocument: createDocumentMutation.mutate,
    updateDocument: updateDocumentMutation.mutate,
    deleteDocument: deleteDocumentMutation.mutate,
    isCreating: createDocumentMutation.isPending,
    isUpdating: updateDocumentMutation.isPending,
    isDeleting: deleteDocumentMutation.isPending,
  };
}
```

### Hook Best Practices

1. **Use TanStack Query for server state**
2. **Use custom hooks for reusable logic**
3. **Handle loading and error states**
4. **Use proper TypeScript typing**
5. **Implement proper error handling**
6. **Use query invalidation for cache updates**
7. **Keep hooks focused and single-purpose**
8. **Use proper cleanup in useEffect**

## Styling and UI

### Component with CVA Pattern

TODO:

```typescript

```

### Tailwind CSS Best Practices

```typescript
// Use Tailwind utility classes
<div className="flex items-center justify-between p-4 bg-white rounded-lg shadow-sm border border-gray-200">
  <h2 className="text-lg font-semibold text-gray-900">Document Title</h2>
  <Button variant="outline" size="sm">
    Edit
  </Button>
</div>

// Use responsive design
<div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
  {items.map((item) => (
    <Card key={item.id}>{item.content}</Card>
  ))}
</div>

// Use dark mode support
<div className="bg-white dark:bg-gray-800 text-gray-900 dark:text-gray-100">
  <h1 className="text-2xl font-bold">Title</h1>
</div>
```

### UI Best Practices

1. **Use Shadcn UI components as base**
2. **Use Radix UI for accessibility**
3. **Use Tailwind CSS for styling**
4. **Use CVA for component variants**
5. **Implement responsive design**
6. **Support dark mode**
7. **Use proper spacing and typography**
8. **Implement proper accessibility**
9. **Use consistent design tokens**
10. **Follow mobile-first approach**

## API Integration

### API Client Pattern

```typescript
import axios from "axios";
import { useAuthStore } from "@/stores/auth-store";

// Create axios instance
export const api = axios.create({
  baseURL: import.meta.env.VITE_API_URL || "http://localhost:3001",
  timeout: 10000,
});

// Request interceptor for authentication
api.interceptors.request.use(
  (config) => {
    const token = localStorage.getItem("token");
    if (token) {
      config.headers.Authorization = `Bearer ${token}`;
    }
    return config;
  },
  (error) => {
    return Promise.reject(error);
  }
);

// Response interceptor for error handling
api.interceptors.response.use(
  (response) => response,
  async (error) => {
    const originalRequest = error.config;

    if (error.response?.status === 401 && !originalRequest._retry) {
      originalRequest._retry = true;

      try {
        const { refreshToken } = useAuthStore.getState();
        await refreshToken();

        const token = localStorage.getItem("token");
        originalRequest.headers.Authorization = `Bearer ${token}`;

        return api(originalRequest);
      } catch (refreshError) {
        useAuthStore.getState().logout();
        return Promise.reject(refreshError);
      }
    }

    return Promise.reject(error);
  }
);

// API functions
export const documentApi = {
  getAll: () => api.get("/documents"),
  getById: (id: string) => api.get(`/documents/${id}`),
  create: (data: CreateDocumentDto) => api.post("/documents", data),
  update: (id: string, data: UpdateDocumentDto) =>
    api.put(`/documents/${id}`, data),
  delete: (id: string) => api.delete(`/documents/${id}`),
};
```

### API Best Practices

1. **Use axios for HTTP requests**
2. **Implement proper authentication**
3. **Handle token refresh automatically**
4. **Use proper error handling**
5. **Implement request/response interceptors**
6. **Use environment variables for configuration**
7. **Implement proper timeout handling**
8. **Use TypeScript for API responses**

## Routing

### Route Configuration Pattern

```typescript
import React from "react";
import { createBrowserRouter, Navigate } from "react-router-dom";
import { Layout } from "@/components/layout/layout";
import { AuthGuard } from "@/router/guards";
import { LoginPage } from "@/pages/auth/login-page";
import { DashboardPage } from "@/pages/dashboard/dashboard-page";
import { DocumentPage } from "@/pages/documents/document-page";
import { SettingsPage } from "@/pages/settings/settings-page";

export const router = createBrowserRouter([
  {
    path: "/",
    element: <Layout />,
    children: [
      {
        index: true,
        element: <Navigate to="/dashboard" replace />,
      },
      {
        path: "login",
        element: <LoginPage />,
      },
      {
        path: "dashboard",
        element: (
          <AuthGuard>
            <DashboardPage />
          </AuthGuard>
        ),
      },
      {
        path: "documents/:id",
        element: (
          <AuthGuard>
            <DocumentPage />
          </AuthGuard>
        ),
      },
      {
        path: "settings",
        element: (
          <AuthGuard>
            <SettingsPage />
          </AuthGuard>
        ),
      },
    ],
  },
]);
```

### Route Guard Pattern

```typescript
import React from "react";
import { Navigate, useLocation } from "react-router-dom";
import { useAuthStore } from "@/stores/auth-store";

interface AuthGuardProps {
  children: React.ReactNode;
}

export function AuthGuard({ children }: AuthGuardProps) {
  const { user, isLoading } = useAuthStore();
  const location = useLocation();

  if (isLoading) {
    return <div>Loading...</div>;
  }

  if (!user) {
    return <Navigate to="/login" state={{ from: location }} replace />;
  }

  return <>{children}</>;
}
```

## Testing Patterns

### Component Test Pattern

```typescript
import React from "react";
import { render, screen, fireEvent, waitFor } from "@testing-library/react";
import { QueryClient, QueryClientProvider } from "@tanstack/react-query";
import { BrowserRouter } from "react-router-dom";
import { UserCard } from "./user-card";

const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      retry: false,
    },
  },
});

const TestWrapper = ({ children }: { children: React.ReactNode }) => (
  <QueryClientProvider client={queryClient}>
    <BrowserRouter>{children}</BrowserRouter>
  </QueryClientProvider>
);

const mockUser = {
  id: "1",
  email: "test@example.com",
  firstName: "John",
  lastName: "Doe",
  role: "user",
  createdAt: new Date(),
  updatedAt: new Date(),
};

describe("UserCard", () => {
  it("renders user information correctly", () => {
    render(
      <TestWrapper>
        <UserCard user={mockUser} />
      </TestWrapper>
    );

    expect(screen.getByText("John Doe")).toBeInTheDocument();
    expect(screen.getByText("test@example.com")).toBeInTheDocument();
  });

  it("calls onEdit when edit button is clicked", () => {
    const onEdit = jest.fn();

    render(
      <TestWrapper>
        <UserCard user={mockUser} onEdit={onEdit} />
      </TestWrapper>
    );

    fireEvent.click(screen.getByText("Edit"));
    expect(onEdit).toHaveBeenCalledWith(mockUser);
  });

  it("calls onDelete when delete button is clicked", async () => {
    const onDelete = jest.fn();

    render(
      <TestWrapper>
        <UserCard user={mockUser} onDelete={onDelete} />
      </TestWrapper>
    );

    fireEvent.click(screen.getByText("Delete"));

    await waitFor(() => {
      expect(onDelete).toHaveBeenCalledWith(mockUser.id);
    });
  });
});
```

### Hook Test Pattern

```typescript
import { renderHook, waitFor } from "@testing-library/react";
import { QueryClient, QueryClientProvider } from "@tanstack/react-query";
import { useDocuments } from "./use-documents";

const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      retry: false,
    },
  },
});

const TestWrapper = ({ children }: { children: React.ReactNode }) => (
  <QueryClientProvider client={queryClient}>{children}</QueryClientProvider>
);

describe("useDocuments", () => {
  it("fetches documents successfully", async () => {
    const mockDocuments = [
      { id: "1", title: "Document 1" },
      { id: "2", title: "Document 2" },
    ];

    // Mock API response
    jest.spyOn(global, "fetch").mockResolvedValueOnce({
      ok: true,
      json: async () => mockDocuments,
    } as Response);

    const { result } = renderHook(() => useDocuments(), {
      wrapper: TestWrapper,
    });

    await waitFor(() => {
      expect(result.current.documents).toEqual(mockDocuments);
    });
  });
});
```

## Performance Optimization

### React.memo and useMemo Pattern

```typescript
import React, { useMemo, useCallback } from "react";

interface UserListProps {
  users: User[];
  onUserSelect: (user: User) => void;
  searchTerm: string;
}

export const UserList = React.memo<UserListProps>(
  ({ users, onUserSelect, searchTerm }) => {
    // Memoize filtered users
    const filteredUsers = useMemo(() => {
      return users.filter(
        (user) =>
          user.firstName.toLowerCase().includes(searchTerm.toLowerCase()) ||
          user.lastName.toLowerCase().includes(searchTerm.toLowerCase())
      );
    }, [users, searchTerm]);

    // Memoize callback
    const handleUserSelect = useCallback(
      (user: User) => {
        onUserSelect(user);
      },
      [onUserSelect]
    );

    return (
      <div className="space-y-2">
        {filteredUsers.map((user) => (
          <UserCard key={user.id} user={user} onSelect={handleUserSelect} />
        ))}
      </div>
    );
  }
);

UserList.displayName = "UserList";
```

### Lazy Loading Pattern

```typescript
import React, { Suspense, lazy } from "react";
import { LoadingSpinner } from "@/components/ui/loading-spinner";

// Lazy load components
const DocumentEditor = lazy(
  () => import("@/components/editor/document-editor")
);
const SettingsPage = lazy(() => import("@/pages/settings/settings-page"));

export function App() {
  return (
    <Suspense fallback={<LoadingSpinner />}>
      <DocumentEditor />
    </Suspense>
  );
}
```

### Performance Best Practices

1. **Use React.memo for expensive components**
2. **Use useMemo for expensive calculations**
3. **Use useCallback for stable references**
4. **Implement lazy loading for routes and components**
5. **Use proper key props for lists**
6. **Avoid unnecessary re-renders**
7. **Use React DevTools Profiler**
8. **Implement proper code splitting**
9. **Optimize bundle size**
10. **Use proper image optimization**

## Modal Management

### react-confirm Pattern

**MANDATORY: All modal dialogs, confirmations, and popups MUST use `react-confirm` library. Do NOT use native browser `confirm()`, `alert()`, or custom modal implementations.**

```typescript
import { confirm } from "react-confirm";

// Basic confirmation dialog
const handleDelete = async () => {
  const confirmed = await confirm({
    title: "Delete Item",
    message:
      "Are you sure you want to delete this item? This action cannot be undone.",
    confirmText: "Delete",
    cancelText: "Cancel",
    variant: "destructive",
  });

  if (confirmed) {
    // Proceed with deletion
    await deleteItem();
  }
};

// Custom confirmation with additional options
const handleSaveChanges = async () => {
  const confirmed = await confirm({
    title: "Save Changes",
    message:
      "You have unsaved changes. Do you want to save them before continuing?",
    confirmText: "Save",
    cancelText: "Discard",
    variant: "default",
    showCancel: true,
    closeOnOverlayClick: false,
  });

  if (confirmed) {
    await saveChanges();
  } else {
    // Discard changes
    resetForm();
  }
};

// Information dialog
const showInfo = async () => {
  await confirm({
    title: "Information",
    message: "Your changes have been saved successfully.",
    confirmText: "OK",
    showCancel: false,
    variant: "default",
  });
};

// Warning dialog
const showWarning = async () => {
  await confirm({
    title: "Warning",
    message:
      "This action will affect multiple items. Please review your selection.",
    confirmText: "Continue",
    cancelText: "Cancel",
    variant: "warning",
  });
};
```

### Modal Best Practices

1. **ALWAYS use react-confirm for all modal interactions**
2. **Use descriptive titles and messages**
3. **Provide clear action button text**
4. **Use appropriate variants (default, destructive, warning)**
5. **Handle async operations properly**
6. **Use proper TypeScript typing**
7. **Implement proper error handling**
8. **Test modal interactions thoroughly**
9. **Ensure accessibility compliance**
10. **Use consistent styling and behavior**

### Forbidden Patterns

**DO NOT use these patterns:**

```typescript
// ❌ NEVER use native browser confirm
if (confirm("Are you sure?")) {
  // action
}

// ❌ NEVER use native browser alert
alert("Operation completed");

// ❌ NEVER create custom modal components for simple confirmations
const [showModal, setShowModal] = useState(false);
// ... custom modal implementation

// ❌ NEVER use window.confirm or window.alert
if (window.confirm("Delete item?")) {
  // action
}
```

### Advanced Modal Patterns

```typescript
// Confirmation with loading state
const handleComplexAction = async () => {
  const confirmed = await confirm({
    title: "Complex Action",
    message: "This will perform multiple operations. Continue?",
    confirmText: "Continue",
    cancelText: "Cancel",
    variant: "default",
  });

  if (!confirmed) return;

  try {
    setIsLoading(true);
    await performComplexAction();
    await confirm({
      title: "Success",
      message: "Operation completed successfully.",
      confirmText: "OK",
      showCancel: false,
    });
  } catch (error) {
    await confirm({
      title: "Error",
      message: "Operation failed. Please try again.",
      confirmText: "OK",
      showCancel: false,
      variant: "destructive",
    });
  } finally {
    setIsLoading(false);
  }
};

// Conditional confirmation
const handleConditionalAction = async () => {
  if (hasUnsavedChanges) {
    const confirmed = await confirm({
      title: "Unsaved Changes",
      message: "You have unsaved changes. Save before continuing?",
      confirmText: "Save & Continue",
      cancelText: "Discard & Continue",
      variant: "warning",
    });

    if (confirmed) {
      await saveChanges();
    }
  }

  // Continue with action
  await performAction();
};
```

## Code Quality and Linting

### Biome Configuration

The project uses Biome for code formatting and linting with the following key rules:

```json
{
  "formatter": {
    "enabled": true,
    "indentStyle": "space",
    "indentWidth": 2,
    "lineWidth": 160
  },
  "javascript": {
    "formatter": {
      "quoteStyle": "double",
      "semicolons": "always"
    }
  }
}
```

### Code Quality Best Practices

1. **Use Biome for formatting and linting**
2. **Follow the established import organization**
3. **Use proper TypeScript types throughout**
4. **Write comprehensive tests for all components**
5. **Use meaningful variable and function names**
6. **Keep functions small and focused**
7. **Use proper error handling**
8. **Document complex business logic**
9. **Use consistent naming conventions**
10. **Follow the established component structure**

## Summary

This React client follows modern TypeScript and React best practices with:

- **Strict typing** throughout the codebase
- **Functional components** with hooks
- **Zustand** for client state management
- **TanStack Query** for server state management
- **TipTap** for rich text editing with collaboration
- **Radix UI and Shadcn UI** for accessible components
- **Tailwind CSS** for utility-first styling
- **React Router** for client-side routing
- **react-confirm** for consistent modal and confirmation management
- **Comprehensive testing** setup with Vitest
- **Code quality** enforced by Biome

Use this guide as the definitive reference for all code generation and development work on this project.
